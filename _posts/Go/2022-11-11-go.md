---
title: "Go 내용 정리"
excerpt: ""

categories:
  - Go

toc: true
toc_sticky: false

date: 2022-11-11
last_modified_at: 2022-11-11
---

# 서론

Learning Go를 읽고 몇 가지 내용을 간단하게 정리해보았다.

<br>

# 기본 데이터 타입

## 리터럴(literal)
- 룬(`rune`) 리터럴은 문자를 의미하며 작은따옴표(')만 사용 가능하다. (`rune` 타입은 `int32` 타입의 별칭)
- 문자열(`string`) 리터럴은 0개 이상의 문자를 담을 수 있으며 큰따옴표(")를 사용하는 방식과 역따옴표(`)를 사용하는 방식이 있다.
  - 큰따옴표(")를 사용하는 방식에서 표현할 수 없는 문자는 역슬래쉬(`\`)를 사용한 이스케이프 문을 통해 표현할 수 있다.
  - 역따옴표(`)를 사용하는 방식은 역따옴표를 제외한 모든 문자를 표현할 수 있다.

## 정수 타입
- `byte` 타입은 `uint8`의 별칭으로 왠만하면 `byte` 타입을 사용한다.
- 일반적으로 정수를 표현할 때는 `int` 타입을 사용하지만, 네트워크 프로토콜처럼 특정 크기를 가지는 정수는 해당 타입을 사용한다.

## 부동소수 타입
- Go는 IEEE 754 표준을 사용하여 부동소수점 값을 표현한다.
- `float32` 타입 보단 정밀도가 높은 `float64` 타입을 권장한다.
- 부동소수점 값은 소수 값을 정확하게 표현할 수 없으므로 돈처럼 정확한 소수 값이 필요한 상황에서 사용하면 안된다.

## const 사용
- Go에서 상수는 리터럴에 이름을 부여할 때 사용한다.
- 즉, 컴파일 타임에 파악할 수 있는 값만 가질 수 있다.
- Go에서는 런타임에 계산된 값을 변경하지 못하게 하는 방법은 제공하지 않는다.
- 타입을 지정하지 않은 `const`는 여러 타입에 할당할 수 있다.

### := 연산자 사용을 피해야 하는 상황
- 제로 값으로 변수를 초기화 하는 상황
  - `x := 0` 보단 `var x int` 선호
- 타입이 지정되지 않은 상수나 리터럴이 변수에 할당되는 상황
  - `x := byte(20)` 보단 `var x byte = 20` 선호
- 이미 있는 변수에 값을 재할당하려는 상황
  - 다른 블록에서 같은 이름의 변수를 재할당하면 섀도잉 변수를 생성한다.

### var와 := 를 같은 라인에 선언해도 되는 경우
- 함수나 콤마 ok 관용구에서 반환된 여러 값을 할당할 때 사용한다.

## 변수 이름 짓기
- 스네이크 표기법(ex. `index_number`) 대신 카멜 표기법(ex. `indexNumber`)을 사용한다.
- 다른 언어에서는 상수 변수명에 대문자와 언더바를 사용하지만 Go에서 첫 번째 문자의 대문자 사용은 패키지 외부에서 접근 가능 유무를 정하기 때문에 사용을 지양한다.
- 함수 내부에서는 최대한 짧은 변수명을 권장한다.
  - Go에서는 코드를 최대한 간결하게 작성하는 것을 선호한다.
  - 만약 짧은 변수명을 추적하기 힘들 경우, 해당 코드 블록은 너무 많은 일을 한다는 뜻이다.

<br>

# 복합 타입

## 배열(array)
- Go에서는 배열을 많이 사용하지 않는다.
  - 배열의 크기도 타입에 포함된다.
  - 배열의 크기를 지정하기 위해 변수를 사용할 수 없다.
  - 같은 타입이지만 크기가 다른 배열 간에 타입 변환이 불가능하다.

## 슬라이스(slice)
- 슬라이스는 일련의 값을 가지는 자료구조로 구성되며 배열 대신 자주 사용한다.
- 내부적으로 확장되는 횟수를 최소화하는 것이 좋다.
- 슬라이스를 정의할 때 길이를 정하는 기준은 다음과 같다.
  - 버퍼로 슬라이스를 사용할 경우, 0이 아닌 길이를 권장한다. (재활용 가능)
  - 그 이외의 경우에는 길이를 0으로 지정하고 `append` 사용을 권장한다.
- 슬라이스의 슬라이싱
  - `s[a:b]` : a ≤ index < b인 원소의 값을 포함하도록 슬라이싱한다.
- 슬라이스에서 슬라이스를 가져올 경우, 값을 복사하지 않고 공유할 수 있다.
  - 완전히 분리하여 사용하고 싶을 경우, `make` 함수를 사용하여 복사한다.
  - 완전한 슬라이스 연산(`s[a:b:c]`)를 사용하면 c-a의 수용력을 가진 새로운 슬라이스를 생성한다.

## 내장 함수
- `len` : 여러 타입(`array`, `slice`, `map`, `string`, `chan`)의 원소 개수를 반환한다.
- `append` : 슬라이스에 새로운 요소 추가한다. (반환된 값을 할당하지 않으면 컴파일 오류가 발생한다.)
- `cap` : 현재 슬라이스의 수용력(capacity) 확인한다.
- `make` : 타입, 길이, 수용력을 지정하는 슬라이스를 생성한다.
- `copy` : 원본 슬라이스로부터 값은 같지만 독립적인 슬라이스를 생성한다.
- `delete` : 맵에 있는 특정 원소를 제거한다.

## 맵(map)

- 맵의 선언 방식은 다양하다.
  - `var m map[string]int` 처럼 선언하면 제로 값인 `nil`이 들어간 상태라 사용할 수 없다. (값을 쓰면 패닉 발생)
    - `m = make(map[string]int)` 로 초기화해야 사용할 수 있다.
  - `m := map[string]int{}` 처럼 선언하면 초기화할 필요가 없다.
- 맵 타입끼리는 비교할 수 없다.

<br>

# 함수(Function)

## 값에 의한 호출을 사용
- Go에서 인자로 넘겨지는 변수는 모두 복사된다.
- 모든 값은 복사되기 때문에 포인터를 사용하지 않는 한 원본의 불변성이 보장된다.
- `map`, `slice`의 경우 포인터로 구현되어 있어서 변경 사항이 반영된다.
  - `map`은 모든 변경 사항이 반영이 되지만 `slice`는 요소 변경만 가능하고 길이를 늘리는 것은 불가능하다.
- `nil` 포인터를 인자로 전달할 경우, 해당 값을 `nil`이 아닌 다른 값으로 만들 수 없다.
  - 인자로 주소 값이 복사되기 때문에 함수 내부에서 주소 값을 변경해도 외부에서 알 수 없다.

## defer
- `defer`는 후입선출(LIFO) 순서로 실행된다.

<br>

# 포인터(pointer)

## new
- 내장 함수 `new`는 포인터 변수를 생성한다.
- 하지만 일반적으로 구조체 포인터 변수를 만드는 경우, `&` 사용을 선호한다. (ex. `x := &Foo{}`)

## 포인터
- 포인터를 사용하면 GC(Garbage Collector)에게 추가적인 작업을 주기 때문에 불필요한 사용을 최소화 하는 것이 좋다.
- 구조체가 크면 클수록 함수로 전달되는 시간은 늘어나기 때문에 포인터를 사용하는 것이 좋다. (1MB 보다 작은 구조체는 값 타입으로 반환하는 것이 더 빠르다.)
- 구조체 슬라이스 vs 구조체 포인터 슬라이스
  - 구조체 슬라이스는 모든 데이터가 메모리에 연속적으로 존재하여 속도가 빠르다.
  - 구조체 포인터 슬라이스는 메모리 전체에 데이터가 흩어져 있어서 속도가 느리다. (전자보다 2배 정도)

<br>

# 구조체(struct), 메서드(method), 인터페이스(interface)

## 값 리시버(value receiver) vs 포인터 리시버(pointer receiver)
- 메서드가 리시버를 수정하지 않으면 값 리시버를 사용한다.
- 메서드가 리시버를 수정하면 포인터 리시버를 사용한다.
- 메서드가 `nil` 인스턴스를 처리해야 하면 포인터 리시버 사용한다. (값 리시버는 처리할 수 없다.)
- 일관성을 위해 메서드 중 하나라도 포인터 리시버를 사용할 경우, 모든 메서드에 대해 포인트 리시버 사용한다.

## 암묵적 인터페이스
- Go는 암묵적 인터페이스를 사용한다.
  - 즉, 구체 타입은 자신이 구현할 인터페이스를 선언하지 않는다.
- Go의 인터페이스는 동적 타입 언어(python, javascript)의 덕 타이핑(duck typing) 방식과 정적 타입 언어(java)의 인터페이스 방식을 혼합한 구조이다.
  - 인터페이스를 구현하는 구체 타입은 인터페이스를 선언할 필요가 없고 인터페이스가 명시한 메서드 조건만 만족하면 된다. (덕타이핑)
  - 코드가 어떤 의존성을 가졌는지 이해하기 쉽게 호출자는 암묵적 인터페이스를 명시한다.
  - 이러한 방식은 타입 안정성과 디커플링(모듈 간 의존도 최소화)을 가능하게 한다.

```go
type LogicProvider struct {}

func (lp LogicProvider) Process(data string) string {
  // business logic
}

type Logic interface {
  Process(data string) string
}

type Client struct {
  L Logic
}

func (c Client) Program() {
  // get data from somewhere
  c.L.Process(data)
}

func main() {
  c := Client{
    L : LogicProvider{},
  }
  c.Program()
}
```
- 암묵적 인터페이스는 의존성 주입(dependency injection)을 쉽게 할 수 있다.
- 인터페이스 사용은 데코레이터 패턴(객체에 동적으로 새로운 책임을 추가할 수 있는 패턴)을 권장한다.

## 빈 인터페이스
- 빈 인터페이스는 어떠한 타입의 값도 저장할 수 있다.
- 이를 활용하기 위해 타입 단언(type assertion)과 타입 스위치(type switch)가 있다.
  - 타입 단언 (ex. `s := i.(string)`)
  - 타입 스위치 (ex. `switch j := i.(type) {`)
- 타입 단언을 사용할 경우, ok 관용구를 사용하여 타입이 정상적으로 변환되었는지 확인하는 것이 좋다.

## 인터페이스를 받고 구조체를 반환
- 인터페이스를 반환하는 함수를 만들면 디커풀링을 잃게 된다.
- 인터페이스를 반환하면 두 가지 문제가 있다.
  - 결합도(coupling) 문제
    - 모듈에 영구적으로 의존한다.
  - 버저닝(versioning) 문제
    - 인터페이스에 새로운 메서드를 추가하면 인터페이스를 사용하는 모든 구체 타입을 수정해야 할 수 있다.
    - 구체 타입을 반환하면 기존 코드를 망가뜨리지 않고 새 메서드를 추가할 수 있다.

## 메서드 타입과 인터페이스
- 구조체의 메서드가 포인터 리시버일 경우, 인터페이스에 대입할 때도 맞춰줘야 한다.

```go
type Abser interface {
  Abs() float64
}

type Vertex struct {
  X, Y float64
}

func (v *Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
  var a Abser
  v := Vertex{3, 4}

  a = &v // 가능
  a = v  // 불가능

  fmt.Println(a.Abs())
}
```

<br>

# 에러(error)

## 센티넬 오류(Centinel Error)
- 더는 처리를 지속할 수 없을 때 사용하는 에러이다.
- 관행적으로 이름은 `Err`로 시작한다.

## Is와 As
- `errors.Is`는 오류가 센티널 오류 인스턴스와 일치하는지 확인한다.
- `errors.As`는 오류가 특정 타입과 일치하는지 확인한다.

<br>

# 동시성(concurrency)

## 동시성 모델
- Go는 순차적 프로세스들의 통신(CSP, Communicating Sequential Processes)에 기반한 동시성 모델을 사용한다.
- 동시성을 사용하면 좋은 상황
  - 독립적으로 수행할 수 있는 작업
  - I/O 작업 (디스크나 네트워크 읽기/쓰기)
- 동시성이 도움이 되는지 확인하기 위해서는 벤치마크 테스트를 하는 것이 좋다.

## 고루틴(Goroutine)
- 고루틴은 Go에서 지원하는 경량 스레드(Light Weight Thread)이다.
- Go 런타임 스케줄러가 자동으로 스레드들을 할당한다.
- 고루틴의 장점
  - 고루틴은 운영체제 레벨 자원을 생성하지 않기 때문에 스레드 생성보다 빠르다.
  - 고루틴의 초기 스택 크기는 스레드의 스택 크기보다 작으며 필요하면 늘릴 수 있다. (효율적인 메모리 관리)
  - 고루틴 간의 전환은 완전히 프로세스 내에서 일어나서 운영체제 시스템콜이 필요한 스레드 전환보다 빠르다.
  - Go 런타임 스케줄러는 Go 프로세스의 일부이기 때문에 스케줄링 결정을 최적화할 수 있다.
- 비즈니스 로직을 감싸는 클로저를 고루틴으로 실행하는 방식이 관례적이다.

## 채널(Channel)
- 채널은 고루틴끼리 메시지를 전달할 수 있는 메시지 큐이다. (FIFO)
- Multi-Thread 환경에서 Lock 없이 쓸 수 있는 Thread-Safe 한 Queue 이다.
- 여러 고루틴에서 같은 채널을 읽어도 결국 하나의 고루틴만 받을 수 있다.
- 채널은 버퍼가 없는 채널과 버퍼가 있는 채널로 나눌 수 있다.
  - 버퍼가 없는 채널에 쓰기를 하면 다른 고루틴에서 채널을 읽기 전까지 해당 고루틴은 일시 중지한다.
  - 버퍼가 있는 채널은 버퍼가 다 채워지면 다른 고루틴에서 채널을 읽기 전까지 해당 고루틴은 일시 중지한다. (버퍼가 없는 채널에 읽기를 해도 해당 고루틴은 일시 중지한다.)

## select 문
- `switch` 문은 여러 채널(`case`) 중 하나에 읽기나 쓰기를 수행한다.
- 임의의 채널을 선택하기 때문에 기아 문제나 교착 상태(deadlock)을 막아준다.
- `for`-`select` 문을 자주 사용한다. (`select`는 한 번만 실행하고 빠져나온다.)

## 고루틴에서 클로저 캡처 시 주의사항
- 보통 고루틴으로 클로저를 사용할 경우, 선언된 환경에서 값을 캡처하는 방식을 사용한다.
- 하지만 `for` 루프 문의 값이나 인덱스를 캡처하는 과정에서 문제가 발생할 수 있다.

```go
a := []int{2, 4, 6, 8, 10}
ch := make(chan int, len(a))

// 이 경우 마지막에 할당된 v 값인 10만 반복해서 들어감
for _, v := range a {
  go func() {
    ch <- v * 2
  }
}

// 의도한 방식대로 동작 (루프 내에서 값을 새도잉 하는 방법)
for _, v := range a {
  v := v
  go func() {
    ch <- v * 2
  }
}

// 의도한 방식대로 동작 (파라미터로 값을 넘기는 방법)
for _, v := range a {
  go func(val int) {
    ch <- val * 2
  }(v)
}
```

## 작업 완료를 기다리는 고루틴
- 단일 고루틴을 기다린다면 `done` 채널 패턴를 선호한다.
  - `done` 패턴은 채널을 만들고 작업이 끝나면 해당 채널를 닫아서 종료를 알린다.

```go
done := make(chan int)

go func() {
  // do something
  close(done)
}()

for {
  select {
  case <-done:
    return
  }
}
```

- 둘 이상의 고루틴을 기다린다면 `sync.WaitGroup` 사용한다.

```go
var wg sync.WaitGroup
wg.Add(3)
go func() {
  defer wg.Done()
  // do something1
}()

go func() {
  defer wg.Done()
  // do something2
}()

go func() {
  defer wg.Done()
  // do something3
}()

wg.Wait()
```

- `sync.WaitGroup`이나 `sync.Once`는 복사될 수 없다. (인자로 넘길거면 포인터를 사용한다.)

## 채널 대신 뮤텍스(mutex)를 사용해야 하는 경우
- 채널을 사용해야 하는 경우
  - 고루틴들을 조정하거나 고루틴에 의해 변경되는 값들을 추적하는 경우
- 뮤텍스를 사용해야 하는 경우
  - 구조체에 항목을 공유하여 접근하는 경우
  - 채널을 사용했을 때 성능상의 문제가 발생하는 경우
- 채널은 데이터의 흐름이 명확하지만 뮤텍스는 데이터의 흐름이 모호하다는 단점이 있다. 

### Byte Order
- 일반적으로 네트워크를 통해 전송되는 데이터는 Big-Endian Format(=Network Byte Order)로 보내진다.
- 하지만 CPU는 대부분 Little-Endian Format으로 데이터를 읽어서 주의가 필요하다.

<br>
